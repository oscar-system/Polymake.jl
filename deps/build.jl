using CxxWrap
using BinaryProvider
using Base.Filesystem
import Pkg
import CMake
using Libdl

# Parse some basic command-line arguments
const verbose = "--verbose" in ARGS

# Dependencies that must be installed before this package can be built
dependencies = [
    "build_bliss.v0.73.0.jl",
    "build_boost.v1.71.0.jl",
    "build_cddlib.v0.94.10.jl",
    "build_FLINT.v2.6.0.jl",
    "build_GMP.v6.1.2.jl",
    "build_lrslib.v0.1.0.jl",
    "build_MPFR.v4.0.2.jl",
    "build_Ncurses.v6.1.0.jl",
    "build_Ninja.v1.10.0.jl",
    "build_normaliz.v3.8.4.jl",
    "build_PPL.v1.2.0.jl",
    "build_Perl.v5.30.3.jl",
    "build_Readline.v8.0.4.jl",
]


pm_config = joinpath(@__DIR__,"usr","bin","polymake-config")
perl = joinpath(@__DIR__,"usr","bin","perl")
use_binary = true
depsjl = ""

if haskey(ENV, "POLYMAKE_CONFIG") && ENV["POLYMAKE_CONFIG"] != "no"
    try
        if ENV["POLYMAKE_CONFIG"] == "yes"
            # test whether polymake config is available in path
            global pm_config = chomp(read(`command -v polymake-config`, String))
        else
            global pm_config = ENV["POLYMAKE_CONFIG"]
        end
        @assert ispath(pm_config)
        global perl ="perl"
        global use_binary = false
    catch err
        if err isa AssertionError
            @error("Environment variable POLYMAKE_CONFIG does not point to a valid `polymake-config` executable.")
        end
        rethrow(err)
    end
end

const prefix = Prefix(joinpath(dirname(pm_config),".."))
const polymake = joinpath(prefix,"bin","polymake")

products = Product[
    LibraryProduct(prefix, "libpolymake", :libpolymake)
    ExecutableProduct(prefix,"polymake", :polymake)
    ExecutableProduct(prefix,"polymake-config", Symbol("polymake_config"))
]

# Download binaries from hosted location
bin_prefix = "https://github.com/benlorenz/polymake_jll.jl/releases/download/polymake-v4.1.0+0"

# Listing of files generated by BinaryBuilder:
download_info = Dict(
    MacOS(:x86_64, compiler_abi=CompilerABI(:gcc_any, :cxx03)) => ("$bin_prefix/polymake.v4.1.0.x86_64-apple-darwin14-cxx03.tar.gz", "5f57b69067cf618b65a841c5bdf05a47983989557abec3386fbdb590ac15642b"),
    MacOS(:x86_64, compiler_abi=CompilerABI(:gcc_any, :cxx11)) => ("$bin_prefix/polymake.v4.1.0.x86_64-apple-darwin14-cxx11.tar.gz", "98f1aa168f947e518d15d193fa5bb02d8e21b844e75dde6a94f029df783d2f1c"),
    Linux(:x86_64, libc=:glibc, compiler_abi=CompilerABI(:gcc6, :cxx11)) => ("$bin_prefix/polymake.v4.1.0.x86_64-linux-gnu-gcc6-cxx11.tar.gz", "ccb4a44242a20e3b377fb46d0933d0d696e8f4b0657610ba155e97a3d48a2b25"),
    Linux(:x86_64, libc=:glibc, compiler_abi=CompilerABI(:gcc7, :cxx11)) => ("$bin_prefix/polymake.v4.1.0.x86_64-linux-gnu-gcc7-cxx11.tar.gz", "aa2c294c1166d047fec55414d47cd423d8f0040c789dfff726b329e4ecb6cc9d"),
    Linux(:x86_64, libc=:glibc, compiler_abi=CompilerABI(:gcc8, :cxx11)) => ("$bin_prefix/polymake.v4.1.0.x86_64-linux-gnu-gcc8-cxx11.tar.gz", "132f2e9455fadb333b392d584b51722e3fc2d8a1fe733c43a36a98662f8ff97f"),
)

if use_binary
    # Install unsatisfied or updated dependencies:
    unsatisfied = any(!satisfied(p; verbose=verbose) for p in products)
    dl_info = choose_download(download_info, platform_key_abi())
    platform = platform_key_abi()
    @info platform
    if dl_info === nothing && unsatisfied
        # If we don't have a BinaryProvider-compatible .tar.gz to download, complain.
        # Alternatively, you could attempt to install from a separate provider,
        # build from source or something even more ambitious here.
        error("""
Your platform $(triplet(platform)) is not supported by this package!
If you already have a polymake installation you need to set the environment variable `POLYMAKE_CONFIG`.
""")
    end
    pm_bin_prefix = joinpath(@__DIR__,"usr")
    if unsatisfied || !isinstalled(dl_info...; prefix=prefix)
        if isdir(pm_bin_prefix)
            # make sure we can overwrite all the directories (e.g. ncurses)
            run(`chmod -R u+w $(pm_bin_prefix)`)
        end
        # Download and install binaries
        for dependency in dependencies          # We do not check for already installed dependencies
            build_file = joinpath(@__DIR__, dependency)
            m = @eval module $(gensym()); include($build_file); end
            append!(products, m.products)
        end
        install(dl_info...; prefix=prefix, force=true, verbose=verbose)
    end
    depsjl = :(
        function prepare_env()
            ENV["POLYMAKE_USER_DIR"] = abspath(joinpath(Pkg.depots1(),"polymake_user"));
            ENV["PATH"] = ENV["PATH"]*":"*joinpath($pm_bin_prefix,"bin");
        end
        )
    eval(depsjl)
    prepare_env()

    rex = Regex("\\s+'$(@__DIR__).*'\\s?=>\\s?'(?<wrappers_dir>wrappers\\.\\d+)'\\s?,?")
    customize_file = joinpath(ENV["POLYMAKE_USER_DIR"], "customize.pl")
    if isfile(customize_file)
        for l in readlines(customize_file)
            m = match(rex, l)
            if m !== nothing && m[:wrappers_dir] !== nothing
                wrappers = joinpath(ENV["POLYMAKE_USER_DIR"], m[:wrappers_dir])
                @info "Removing $(wrappers)"
                rm(wrappers, force=true, recursive=true)
            end
        end
    end

    pm_config_ninja = joinpath(libdir(prefix),"polymake","config.ninja")
    run(`$perl -pi -e "s{/workspace/destdir}{$pm_bin_prefix}g" $pm_config_ninja`)

    # adjust signal used for initalization purposes to avoid problems
    run(`$perl -pi -e "s/SIG{INT}/SIG{USR1}/g" $pm_bin_prefix/share/polymake/perllib/Polymake/Main.pm`)

else
    if pm_config == nothing
        error("Set `POLYMAKE_CONFIG` ENV variable. And rebuild Polymake by calling `import Pkg; Pkg.build(\"Polymake\")`.")
    end
end

minimal_polymake_version = v"4.0"

pm_version = read(`$perl $pm_config --version`, String) |> chomp |> VersionNumber
if pm_version < minimal_polymake_version
    error("Polymake version $pm_version is older than minimal required version $minimal_polymake_version")
end

pm_include_statements = read(`$perl $pm_config --includes`, String) |> chomp |> split
# Remove the -I prefix of all includes
pm_include_statements = map(i -> i[3:end], pm_include_statements)
push!(pm_include_statements, joinpath(pm_include_statements[1],"..","share","polymake"))
pm_includes = join(pm_include_statements, " ")

pm_cflags = chomp(read(`$perl $pm_config --cflags`, String))
pm_ldflags = chomp(read(`$perl $pm_config --ldflags`, String))
pm_libraries = chomp(read(`$perl $pm_config --libs`, String))
pm_cxx = chomp(read(`$perl $pm_config --cc`, String))

jlcxx_cmake_dir = joinpath(CxxWrap.prefix_path(), "lib", "cmake", "JlCxx")
julia_exec = joinpath(Sys.BINDIR, Base.julia_exename())

xcode_typeinfo_bug = false

if Sys.isapple()
   # Work around a bug in Xcode 11.4 that causes SIGABRT, at least until
   # https://github.com/llvm/llvm-project/commit/2464d8135e
   # arrives.
   #
   # We build a jlcxx library that uses std::string which will
   # abort with a failed assertion has_julia_type<T> if we are building
   # with xcode 11.4 but libcxxwrap-julia was built with an older libc++.
   #
   # Read the above LLVM commit message for some details; the effect of merged
   # vs non-merged type_info is that for the former memory addresses are
   # used as hash_code(), for the latter the type_info.name() string is
   # hashed.

   cd(joinpath(@__DIR__, "xcodetypeinfo"))
   run(`$(CMake.cmake) -DJulia_EXECUTABLE=$julia_exec -DJlCxx_DIR=$jlcxx_cmake_dir .`)
   run(`make -j1`)
   libpath = joinpath(@__DIR__, "xcodetypeinfo", "libhello.$dlext")
   res = run(pipeline(Cmd(`$(Base.julia_cmd()) --project -e "using CxxWrap; @wrapmodule(\"$libpath\", :define_module_hello); @initcxx;"`,ignorestatus=true),stdout=devnull,stderr=devnull))
   if res.termsignal == 6
      global xcode_typeinfo_bug = true
      println("Applying Xcode type_info.hash_code() workaround")
   end
end

cd(joinpath(@__DIR__, "src"))

include("type_setup.jl")

if xcode_typeinfo_bug
   global pm_cflags *= " -DFORCE_XCODE_TYPEINFO_MERGED"
end

run(`$(CMake.cmake)
    -DJulia_EXECUTABLE=$julia_exec
    -DJlCxx_DIR=$jlcxx_cmake_dir
    -Dpolymake_includes=$pm_includes
    -Dpolymake_ldflags=$pm_ldflags
    -Dpolymake_libs=$pm_libraries
    -Dpolymake_cflags=$pm_cflags
    -DCMAKE_CXX_COMPILER=$pm_cxx
    -DCMAKE_INSTALL_LIBDIR=lib
    .`)
cpus = max(div(Sys.CPU_THREADS,2), 1)
run(`make -j$cpus`)

json_script = joinpath(@__DIR__,"rules","apptojson.pl")
json_folder = joinpath(@__DIR__,"json")
mkpath(json_folder)

run(`$perl $polymake --no-config --iscript $json_script $json_folder`)

# remove old deps.jl first to avoid problems when switching from binary installation
rm(joinpath(@__DIR__,"deps.jl"), force=true)

if use_binary
    # Write out a deps.jl file that will contain mappings for our products
    write_deps_file(joinpath(@__DIR__, "deps.jl"), Array{Product,1}(products), verbose=verbose)
end

println("appending to deps.jl file")
open(joinpath(@__DIR__,"deps.jl"), "a") do f
   println(f, "const using_binary = $use_binary")
   println(f, depsjl)
end

println("storing libcxxwrap version")
jlcxxversion = VersionNumber(unsafe_string(ccall(:cxxwrap_version_string, Cstring, ())))
open(joinpath(@__DIR__,"jlcxx_version.jl"), "w") do f
   println(f, """const jlcxx_version = v"$jlcxxversion";""")
end
