var documenterSearchIndex = {"docs":
[{"location":"using_polymake_jl/#Using-Polymake.jl","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"","category":"section"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"In this section, the main functionality of Polymake.jl is covered: how to access polymake's powerful abilities. For this cause one needs to know how to call polymake methods and how to handle the supported types.","category":"page"},{"location":"using_polymake_jl/#Executing-Polymake-Methods","page":"Using Polymake.jl","title":"Executing Polymake Methods","text":"","category":"section"},{"location":"using_polymake_jl/#Directly-calling-a-polymake-method","page":"Using Polymake.jl","title":"Directly calling a polymake method","text":"","category":"section"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"One of the simplest yet most useful possibilities Polymake.jl offers is to directly use a polymake method via the following macro:","category":"page"},{"location":"using_polymake_jl/#Polymake.@pm","page":"Using Polymake.jl","title":"Polymake.@pm","text":"@pm polymakeapp.function_name{Template, parameters}(args)\n\nThis macro can be used to\n\ncreate polymake Big Objects (such as polytopes)\ncall polymake functions with specific template parameters.\n\nThe expression passed to the macro has to be:\n\na fully qualified name of a polymake object (i.e. starting with the\n\nlowercase name of a polymake application), or\n\na function with template parameters enclosed in { ... }.\n\nExamples\n\njulia> P = @pm polytope.Polytope{QuadraticExtension}(POINTS=[1 0 0; 0 1 0])\ntype: Polytope<QuadraticExtension<Rational>>\n\nPOINTS\n1 0 0\n0 1 0\n\n\n\njulia> @pm common.convert_to{Float}(P)\ntype: Polytope<Float>\n\nPOINTS\n1 0 0\n0 1 0\n\n\nCONE_AMBIENT_DIM\n3\n\n\n\njulia> @pm tropical.Polytope{Max}(POINTS=[1 0 0; 0 1 0])\ntype: Polytope<Max, Rational>\n\nPOINTS\n0 -1 -1\n0 1 0\n\n\n\n\n!!! Note     the expression in @pm macro is parsed syntactically, so it has to be a valid julia expression. However template parameters need not to be defined in julia, but must be valid names of polymake property types. Nested types (such as {QuadraticExtension{Rational}}) are allowed.\n\n\n\n\n\n","category":"macro"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"The @pm macro can be used to issue more complicated calls to polymake from julia. If You need to pass templates to BigObjects, some limited support is provided in costructors. For example one can construct polytope.Polytope{Float64}(...). However for this to work templates need to be valid julia types/object, hence it is not possible to construct a Polytope<QuadraticExtension> through such call. For this (and in general: for passing more complicated templates) one needs the @pm macro:","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"$obj = new BigObject<Template,Parameters>(args)","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"becomes","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"obj = @pm appname.BigObject{Template, Parameters}(args)","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"Examples:","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"tropical.Polytope{max, Polymake.Rational}(POINTS=[1 0 0; 1 1 0; 1 1 1])\n# call to constructor, note that max is a julia function, hence a valid object\n@pm tropical.Polytope{Max, QuadraticExtension}(POINTS=[1 0 0; 1 1 0; 1 1 1])\n# macro call: none of the types in templates need to exist in julia","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"As a rule of thumb any template passed to @pm macro needs to be translatable on syntax level to a C++ one. E.g. Matrix{Integer} works, as it translates to pm::Matrix<pm::Integer>.","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"Such templates can be passed to functions as well. A very useful example is the common.convert_to:","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"julia> c = polytope.cube(3);\n\njulia> f = c.FACETS;\n\njulia> f[1,1] # f is an opaque pm::perl::PropertyValue to julia\nERROR: MethodError: no method matching getindex(::Polymake.PropertyValueAllocated, ::Int64, ::Int64)\nStacktrace:\n  [...]\n\njulia> m = @pm common.convert_to{Matrix{Integer}}(f) # the template must consist of C++ names\npm::Matrix<pm::Integer>\n1 1 0 0\n1 -1 0 0\n1 0 1 0\n1 0 -1 0\n1 0 0 1\n1 0 0 -1\n\njulia> m[1,1]\n1","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"Since the combination of the @pm macro and common.convert_to is quite common there is a specialized @convert_to macro for this:","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"\njulia> m = @convert_to Matrix{Integer} f # the template must consist of C++ names\npm::Matrix<pm::Integer>\n1 1 0 0\n1 -1 0 0\n1 0 1 0\n1 0 -1 0\n1 0 0 1\n1 0 0 -1","category":"page"},{"location":"using_polymake_jl/#Wrapped-methods","page":"Using Polymake.jl","title":"Wrapped methods","text":"","category":"section"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"As the @pm macro allows to access polymake's library, there is no need for every method to be wrapped. In general, the wrapped methods restrict to simpler ones in the context of small types, guaranteeing compatibility with julia or allowing easy modification/operations of/with instances of these types. This results in a handling of these types which is equivalent to julia's syntax, e.g. arrays can be accessed with the brackets operator [] or addition can be applied by using +:","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"julia> m = Polymake.Matrix{Polymake.Rational}(4,6)\npm::Matrix<pm::Rational>\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n\n\njulia> m[2,1] = 9\n9\n\njulia> m\npm::Matrix<pm::Rational>\n0 0 0 0 0 0\n9 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n\njulia> a = Polymake.TropicalNumber{Polymake.Min}(7)\npm::TropicalNumber<pm::Min, pm::Rational>\n7\n\njulia> b = Polymake.TropicalNumber{Polymake.Min}(10)\npm::TropicalNumber<pm::Min, pm::Rational>\n10\n\njulia> a + b\npm::TropicalNumber<pm::Min, pm::Rational>\n7","category":"page"},{"location":"using_polymake_jl/#Function-Arguments","page":"Using Polymake.jl","title":"Function Arguments","text":"","category":"section"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"Functions in Polymake.jl accept the following types for their arguments:","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"simple data types (bools, machine integers, floats)\nwrapped native types (Polymake.Integer, Polymake.Rational, Polymake.Vector, Polymake.Matrix, Polymake.Set etc.)\nother objects returned by polymake:\nPolymake.BigObject,\nPolymake.PropertyValue (containers opaque to Julia)","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"If an object passed to Polymake.jl function is of a different type the software will try its best to convert it to a known one. However, if the conversion doesn't work an ArgumentError will be thrown:","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"ERROR: ArgumentError: Unrecognized argument type: SomeType.\nYou need to convert to polymake compatible type first.","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"You can tell Polymake.jl how to convert it by definig","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"Base.convert(::Type{Polymake.PolymakeType}, x::SomeType)","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"The returned value must be of one of the types as above. For example to use AbstractAlgebra.jl matrices as input to Polymake.jl one may define","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"Base.convert(::Type{Polymake.PolymakeType}, M::Generic.MatSpaceElem) = Polymake.Matrix(M.entries)","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"and the following should run smoothly.","category":"page"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"julia> using AbstractAlgebra, Polymake\npolymake version 4.0\nCopyright (c) 1997-2020\nEwgenij Gawrilow, Michael Joswig (TU Berlin)\nhttps://polymake.org\n\nThis is free software licensed under GPL; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n\njulia> mm = AbstractAlgebra.matrix(ZZ, [1 2 3; 4 5 6])\n[1 2 3]\n[4 5 6]\n\njulia> polytope.Polytope(POINTS=mm)\nERROR: ArgumentError: Unrecognized argument type: AbstractAlgebra.Generic.MatSpaceElem{Int64}.\nYou need to convert to polymake compatible type first.\n  [...]\n\njulia> Base.convert(::Type{Polymake.PolymakeType}, M::Generic.MatSpaceElem) = Polymake.Matrix(M.entries)\n\njulia> polytope.Polytope(POINTS=mm)\ntype: Polytope<Rational>\n\nPOINTS\n1 2 3\n1 5/4 3/2\n","category":"page"},{"location":"using_polymake_jl/#Accessing-the-polyDB","page":"Using Polymake.jl","title":"Accessing the polyDB","text":"","category":"section"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"Polymake.jl allows the user to access the objects stored within the polyDB via the Mongoc.jl package; this functionality can be found in another sub-module, Polymake.Polydb, which requires no additional interaction to be loaded. It offers two different ways for querying, as well as some methods for information. For demonstration purposes, there also is a Jupyter notebook in the examples/ folder.","category":"page"},{"location":"using_polymake_jl/#General-tools","page":"Using Polymake.jl","title":"General tools","text":"","category":"section"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"There are three types one needs to know when working with Polymake.Polydb:","category":"page"},{"location":"using_polymake_jl/#Polymake.Polydb.Database","page":"Using Polymake.jl","title":"Polymake.Polydb.Database","text":"  Database\n\nType for referencing a specific database (usually the polyDB)\n\n\n\n\n\n","category":"type"},{"location":"using_polymake_jl/#Polymake.Polydb.Collection","page":"Using Polymake.jl","title":"Polymake.Polydb.Collection","text":"  Collection{T}\n\nType for referencing a specific collection. T<:Union{Polymake.BigObject, Mongoc.BSON} defines the template and/or element types returned by operations applied on objects of this type.\n\n\n\n\n\n","category":"type"},{"location":"using_polymake_jl/#Polymake.Polydb.Cursor","page":"Using Polymake.jl","title":"Polymake.Polydb.Cursor","text":"  Cursor{T}\n\nType containing the results of a query. Can be iterated, but the iterator can not be reset. For this cause, one has to query again. T<:Union{Polymake.BigObject, Mongoc.BSON} defines the element types.\n\n\n\n\n\n","category":"type"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"To receive the Database object referencing to the polyDB, there is the get_db() method:","category":"page"},{"location":"using_polymake_jl/#Polymake.Polydb.get_db-Tuple{}","page":"Using Polymake.jl","title":"Polymake.Polydb.get_db","text":"  get_db()\n\nConnect to the polyDB and return Database instance.\n\nThe uri of the server can be set in advance by writing its String representation into ENV[\"POLYDBTESTURI\"]. (used to connect to the github services container for testing)\n\nExamples\n\njulia> db = Polymake.Polydb.get_db();\n\njulia> typeof(db)\nPolymake.Polydb.Database\n\n\n\n\n\n","category":"method"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"A specific Collection object can then be obtained with the brackets operator:","category":"page"},{"location":"using_polymake_jl/#Base.getindex-Tuple{Polymake.Polydb.Database, String}","page":"Using Polymake.jl","title":"Base.getindex","text":"  getindex(db::Database, name::AbstractString)\n\nReturn a Polymake.Polydb.Collection{Polymake.BigObject} instance from db with the given name. Sections and collections in the name are connected with the '.' sign.\n\nExamples\n\njulia> db = Polymake.Polydb.get_db();\n\njulia> collection = getindex(db, \"Polytopes.Lattice.SmoothReflexive\")\nPolymake.Polydb.Collection{Polymake.BigObject}: Polytopes.Lattice.SmoothReflexive\n\njulia> collection = db[\"Matroids.Small\"]\nPolymake.Polydb.Collection{Polymake.BigObject}: Matroids.Small\n\n\n\n\n\n","category":"method"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"By default, the results are parsed to Polymake.BigObjects when accessed, but one may choose to change this behaviour by adjusting the typing template of Collection or Cursor using the following method:","category":"page"},{"location":"using_polymake_jl/#Polymake.Polydb.Collection-Tuple{Polymake.Polydb.Collection}","page":"Using Polymake.jl","title":"Polymake.Polydb.Collection","text":"  Collection{T}(c::Collection)\n\nCreate another Collection object with a specific template parameter referencing the same collection as c. T can be chosen from Polymake.BigObject and Mongoc.BSON.\n\nExamples\n\njulia> db = Polymake.Polydb.get_db();\n\njulia> collection = db[\"Polytopes.Lattice.SmoothReflexive\"]\nPolymake.Polydb.Collection{Polymake.BigObject}: Polytopes.Lattice.SmoothReflexive\n\njulia> collection_bson = Polymake.Polydb.Collection{Mongoc.BSON}(collection)\nPolymake.Polydb.Collection{Mongoc.BSON}: Polytopes.Lattice.SmoothReflexive\n\njulia> collection_bo = Polymake.Polydb.Collection{Polymake.BigObject}(collection_bson)\nPolymake.Polydb.Collection{Polymake.BigObject}: Polytopes.Lattice.SmoothReflexive\n\n\n\n\n\n","category":"method"},{"location":"using_polymake_jl/#Information","page":"Using Polymake.jl","title":"Information","text":"","category":"section"},{"location":"using_polymake_jl/#Polymake.Polydb.info","page":"Using Polymake.jl","title":"Polymake.Polydb.info","text":"  info(db::Database, level::Base.Integer=1)\n\nPrint a structured list of the sections and collections of the Polydb together with information about each of these (if existent).\n\nDetail of the output determined by value of level:\n\n1: short description,\n2: description,\n3: description, authors, maintainers,\n4: full info,\n5: full info and list of recommended search fields.\n\n\n\n\n\n  info(c::Collection, level::Base.Integer=1)\n\nPrint information about collection c (if existent).\n\nDetail of the output determined by value of level:\n\n1: short description,\n2: description,\n3: description, authors, maintainers,\n4: full info,\n5: full info and list of recommended search fields.\n\n\n\n\n\n","category":"function"},{"location":"using_polymake_jl/#Polymake.Polydb.get_collection_names","page":"Using Polymake.jl","title":"Polymake.Polydb.get_collection_names","text":"  get_collection_names(db::Database)\n\nReturn a Vector{String} containing the names of all collections in the Polydb, excluding meta collections.\n\nExamples\n\njulia> db = Polymake.Polydb.get_db();\n\njulia> Polymake.Polydb.get_collection_names(db)\n16-element Vector{String}:\n \"Polytopes.Combinatorial.FacesBirkhoffPolytope\"\n \"Polytopes.Combinatorial.SmallSpheresDim4\"\n \"Polytopes.Geometric.01Polytopes\"\n \"Polytopes.Lattice.SmoothReflexive\"\n \"Polytopes.Lattice.ExceptionalMaximalHollow\"\n \"Tropical.TOM\"\n ⋮\n \"Polytopes.Lattice.Panoptigons\"\n \"Tropical.Cubics\"\n \"Tropical.SchlaefliFan\"\n \"Polytopes.Lattice.Reflexive\"\n \"Polytopes.Combinatorial.CombinatorialTypes\"\n\n\n\n\n\n","category":"function"},{"location":"using_polymake_jl/#Polymake.Polydb.get_fields","page":"Using Polymake.jl","title":"Polymake.Polydb.get_fields","text":"  get_fields(c::Collection)\n\nReturn a Vector{String} containing the names of the fields of c.\n\nExamples\n\njulia> db = Polymake.Polydb.get_db();\n\njulia> collection = db[\"Matroids.Small\"]\nPolymake.Polydb.Collection{Polymake.BigObject}: Matroids.Small\n\njulia> Polymake.Polydb.get_fields(collection)\n27-element Vector{String}:\n \"DUAL\"\n \"N_BASES\"\n \"TUTTE_POLYNOMIAL\"\n \"SERIES_PARALLEL\"\n \"N_FLATS\"\n \"SPLIT_FLACETS\"\n ⋮\n \"TERNARY\"\n \"REGULAR\"\n \"TRANSVERSAL\"\n \"IDENTICALLY_SELF_DUAL\"\n \"BETA_INVARIANT\"\n\n\n\n\n\n","category":"function"},{"location":"using_polymake_jl/#Querying","page":"Using Polymake.jl","title":"Querying","text":"","category":"section"},{"location":"using_polymake_jl/","page":"Using Polymake.jl","title":"Using Polymake.jl","text":"There are two ways for querying within Polymake.jl.","category":"page"},{"location":"using_polymake_jl/#Methods","page":"Using Polymake.jl","title":"Methods","text":"","category":"section"},{"location":"using_polymake_jl/#Mongoc.find","page":"Using Polymake.jl","title":"Mongoc.find","text":"find(collection::Collection, bson_filter::BSON=BSON();\n    options::Union{Nothing, BSON}=nothing) :: Cursor\n\nExecutes a query on collection and returns an iterable Cursor.\n\nExample\n\nfunction find_contract_codes(collection, criteria::Dict=Dict()) :: Vector{String}\n    result = Vector{String}()\n\n    let\n        bson_filter = Mongoc.BSON(criteria)\n        bson_options = Mongoc.BSON(\"\"\"{ \"projection\" : { \"_id\" : true }, \"sort\" : { \"_id\" : 1 } }\"\"\")\n        for bson_document in Mongoc.find(collection, bson_filter, options=bson_options)\n            push!(result, bson_document[\"_id\"])\n        end\n    end\n\n    return result\nend\n\nCheck the libmongoc documentation for more information.\n\n\n\n\n\nfind(bucket::Bucket, bson_filter::BSON=BSON();\n    options::BSON=BSON()) :: Cursor\n\nLooks for files in GridFS bucket.\n\n\n\n\n\n  find(c::Collection{T}, d::Dict=Dict(); opts::Union{Nothing, Dict})\n\nSearch a collection c for documents matching the criteria given by d. Apply search options opts.\n\nExamples\n\njulia> db = Polymake.Polydb.get_db();\n\njulia> collection = db[\"Polytopes.Lattice.SmoothReflexive\"];\n\njulia> query = Dict(\"DIM\"=>3, \"N_FACETS\"=>5);\n\njulia> results = Polymake.Polydb.find(collection, query);\n\njulia> typeof(results)\nPolymake.Polydb.Cursor{Polymake.BigObject}\n\n\n\n\n\n  find(c::Collection{T}, d::Pair...)\n\nSearch a collection c for documents matching the criteria given by d.\n\nExamples\n\njulia> db = Polymake.Polydb.get_db();\n\njulia> collection = db[\"Polytopes.Lattice.SmoothReflexive\"];\n\njulia> results = Polymake.Polydb.find(collection, \"DIM\"=>3, \"N_FACETS\"=>5);\n\njulia> typeof(results)\nPolymake.Polydb.Cursor{Polymake.BigObject}\n\n\n\n\n\n","category":"function"},{"location":"using_polymake_jl/#Macros","page":"Using Polymake.jl","title":"Macros","text":"","category":"section"},{"location":"using_polymake_jl/#Polymake.Polydb.@select","page":"Using Polymake.jl","title":"Polymake.Polydb.@select","text":"Polymake.Polydb.@select collectionName\n\nThis macro can be used as part of a chain for easy (i.e. human readable) querying. Generate a method asking a container for the entry with key collectionName.\n\nSee also: @filter, @map\n\nExamples\n\njulia> db = Polymake.Polydb.get_db();\n\njulia> collection = db |>\n       Polymake.Polydb.@select(\"Polytopes.Lattice.SmoothReflexive\")\nPolymake.Polydb.Collection{Polymake.BigObject}: Polytopes.Lattice.SmoothReflexive\n\n\n\n\n\n","category":"macro"},{"location":"using_polymake_jl/#Polymake.Polydb.@filter","page":"Using Polymake.jl","title":"Polymake.Polydb.@filter","text":"Polymake.Polydb.@filter conditions...\n\nThis macro can be used as part of a chain for easy (i.e. human readable) querying. Convert conditions into the corresponding Dict and generate a method expanding its input by this Dict. Multiple conditions can be passed in the same line and/or in different lines.\n\nSee also: @select, @map\n\nExamples\n\njulia> db = Polymake.Polydb.get_db();\n\njulia> query_tuple = db |>\n       Polymake.Polydb.@select(\"Polytopes.Lattice.SmoothReflexive\") |>\n       Polymake.Polydb.@filter(\"DIM\" <= 3) |>\n       Polymake.Polydb.@filter(\"N_VERTICES\" == 8)\n(Polymake.Polydb.Collection{Polymake.BigObject}\n    COLLECTION: Polytopes.Lattice.SmoothReflexive\n    Smooth reflexive lattice polytopes in dimensions up to 9, up to lattice equivalence. The lists were computed with the algorithm of Mikkel Oebro (see [[http://arxiv.org/abs/0704.0049|arxiv: 0704.0049]]) and are taken from the [[http://polymake.org/polytopes/paffenholz/www/fano.html|website of Andreas Paffenholz]]. They also contain splitting data according to [[https://arxiv.org/abs/1711.02936| arxiv: 1711.02936]].\n    Authored by\n        Andreas Paffenholz, paffenholz@opt.tu-darmstadt.de, TU Darmstadt\n        Benjamin Lorenz, paffenholz@opt.tu-darmstadt.de, TU Berlin\n        Mikkel Oebro\n    Fields: AFFINE_HULL, CONE_DIM, DIM, EHRHART_POLYNOMIAL, F_VECTOR, FACET_SIZES, FACET_WIDTHS, FACETS, H_STAR_VECTOR, LATTICE_DEGREE, LATTICE_VOLUME, LINEALITY_SPACE, N_BOUNDARY_LATTICE_POINTS, N_EDGES, N_FACETS, N_INTERIOR_LATTICE_POINTS, N_LATTICE_POINTS, N_RIDGES, N_VERTICES, REFLEXIVE, SMOOTH, SELF_DUAL, SIMPLE, TERMINAL, VERTEX_SIZES, VERTICES, VERTICES_IN_FACETS, VERY_AMPLE, ALTSHULER_DET, BALANCED, CENTROID, DIAMETER, NORMAL, N_HILBERT_BASIS, IS_PRISM, IS_PRODUCT, IS_SKEW_PRISM, IS_SIMPLEX_SUM, PRISM_BASE, PRODUCT_FACTORS, SIMPLEX_SUM_BASES, SKEW_PRISM_BASES, Dict{String,Any}(\"DIM\" => Dict{String,Any}(\"$lte\" => 3),\"N_VERTICES\" => Dict{String,Any}(\"$eq\" => 8)))\n\njulia> query_tuple = db |>\n       Polymake.Polydb.@select(\"Polytopes.Lattice.SmoothReflexive\") |>\n       Polymake.Polydb.@filter(\"DIM\" <= 3, \"N_VERTICES\" == 8)\n(Polymake.Polydb.Collection{Polymake.BigObject}\n    COLLECTION: Polytopes.Lattice.SmoothReflexive\n    Smooth reflexive lattice polytopes in dimensions up to 9, up to lattice equivalence. The lists were computed with the algorithm of Mikkel Oebro (see [[http://arxiv.org/abs/0704.0049|arxiv: 0704.0049]]) and are taken from the [[http://polymake.org/polytopes/paffenholz/www/fano.html|website of Andreas Paffenholz]]. They also contain splitting data according to [[https://arxiv.org/abs/1711.02936| arxiv: 1711.02936]].\n    Authored by\n        Andreas Paffenholz, paffenholz@opt.tu-darmstadt.de, TU Darmstadt\n        Benjamin Lorenz, paffenholz@opt.tu-darmstadt.de, TU Berlin\n        Mikkel Oebro\n    Fields: AFFINE_HULL, CONE_DIM, DIM, EHRHART_POLYNOMIAL, F_VECTOR, FACET_SIZES, FACET_WIDTHS, FACETS, H_STAR_VECTOR, LATTICE_DEGREE, LATTICE_VOLUME, LINEALITY_SPACE, N_BOUNDARY_LATTICE_POINTS, N_EDGES, N_FACETS, N_INTERIOR_LATTICE_POINTS, N_LATTICE_POINTS, N_RIDGES, N_VERTICES, REFLEXIVE, SMOOTH, SELF_DUAL, SIMPLE, TERMINAL, VERTEX_SIZES, VERTICES, VERTICES_IN_FACETS, VERY_AMPLE, ALTSHULER_DET, BALANCED, CENTROID, DIAMETER, NORMAL, N_HILBERT_BASIS, IS_PRISM, IS_PRODUCT, IS_SKEW_PRISM, IS_SIMPLEX_SUM, PRISM_BASE, PRODUCT_FACTORS, SIMPLEX_SUM_BASES, SKEW_PRISM_BASES, Dict{String,Any}(\"DIM\" => Dict{String,Any}(\"$lte\" => 3),\"N_VERTICES\" => Dict{String,Any}(\"$eq\" => 8)))\n\n\n\n\n\n","category":"macro"},{"location":"using_polymake_jl/#Polymake.Polydb.@map","page":"Using Polymake.jl","title":"Polymake.Polydb.@map","text":"Polymake.Polydb.@map [optFields...]\n\nThis macro can be used as part of a chain for easy (i.e. human readable) querying. Generate a method running a query given a Tuple{Collection, Dict}. If optFields are given (as Strings), the results only contain the stated fields and the objects metadata.\n\nSee also: @select, @filter\n\nExamples\n\njulia> db = Polymake.Polydb.get_db();\n\njulia> results = db |>\n       Polymake.Polydb.@select(\"Polytopes.Lattice.SmoothReflexive\") |>\n       Polymake.Polydb.@filter(\"DIM\" == 3, \"N_VERTICES\" == 8) |>\n       Polymake.Polydb.@map() |>\n       collect\n7-element Vector{Polymake.BigObject}:\n Polymake.BigObjectAllocated(Ptr{Nothing} @0x00000000028c5320)\n Polymake.BigObjectAllocated(Ptr{Nothing} @0x000000000abd7b40)\n Polymake.BigObjectAllocated(Ptr{Nothing} @0x000000000a6d7bf0)\n Polymake.BigObjectAllocated(Ptr{Nothing} @0x000000000a431470)\n Polymake.BigObjectAllocated(Ptr{Nothing} @0x000000000bcaf290)\n Polymake.BigObjectAllocated(Ptr{Nothing} @0x00000000098fb670)\n Polymake.BigObjectAllocated(Ptr{Nothing} @0x000000000a1ba460)\n\n\n\n\n\n","category":"macro"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page covers the installation of Polymake.jl and where to find help.","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The installation can be done in the Julia's REPL by executing","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using Pkg; Pkg.add(\"Polymake\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This will fetch a pre-built binary of polymake. You are ready to start using Polymake.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Note: Pre-built binaries are available for the Linux and macOS platform, but the macOS binaries are considered experimental. Windows users are encouraged to try running Julia inside Window Subsystem for Linux and reporting back ;)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Note: Pre-built polymake will use a separate .polymake config directory (usually joinpath(homedir(), \".julia\", \"polymake_user\")).","category":"page"},{"location":"getting_started/#Getting-Help","page":"Getting Started","title":"Getting Help","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For basic information on the usage of Polymake.jl we refer to the other sections of this documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For further details on polymake and its abilities see the Polymake User Guide.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this section we just highlight various possible uses of Polymake.jl. Please refer to Polymake syntax translation for more thorough treatment.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"polymake big objects (like Polytope, Cone, etc) constructors live within modules named after polymake applications, e.g.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Call the Polytope constructor\njulia> p = polytope.Polytope(POINTS=[1 -1 -1; 1 1 -1; 1 -1 1; 1 1 1; 1 0 0])\ntype: Polytope<Rational>\n\nPOINTS\n1 -1 -1\n1 1 -1\n1 -1 1\n1 1 1\n1 0 0\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Parameters to constructors can be passed as keyword arguments only. All the keys must be compatible with polymake input attribute names.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Properties of such objects can be accessed by the . syntax:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p.INTERIOR_LATTICE_POINTS\npm::Matrix<pm::Integer>\n1 0 0","category":"page"},{"location":"examples/#Example-script","page":"Examples","title":"Example script","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following script is modelled on the one from the Using Perl within polymake tutorial:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Polymake\n\nstr = read(\"points.demo\", String)\n# eval/parse is a hack for Rational input, don't do this at home!\nmatrix_str = \"[\"*replace(str, \"/\"=>\"//\")*\"]\"\nmatrix = eval(Meta.parse(matrix_str))\n@show matrix\n\np = polytope.Polytope(POINTS=matrix)\n\n@show p.FACETS # polymake matrix of polymake rationals\n@show polytope.dim(p) # Julia Int64\n# note that even in Polymake property DIM is \"fake\" -- it's actually a function\n@show p.VERTEX_SIZES # polymake array of ints\n@show p.VERTICES\n\nfor (i, vsize) in enumerate(p.VERTEX_SIZES)\n  if vsize == polytope.dim(p)\n    println(\"$i : $(p.VERTICES[i,:])\")\n    # $i will be shifted by one from the polymake version\n  end\nend\n\nsimple_verts = [i for (i, vsize) in enumerate(p.VERTEX_SIZES) if vsize == polytope.dim(p)] # Julia vector of Int64s\n\nspecial_points = p.VERTICES[simple_verts, :] # polymake Matrix of rationals\n@show special_points;","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The script included (i.e. in running REPL execute include(\"example_script.jl\");) produces the following output:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"matrix = Rational{Int64}[1//1 0//1 0//1 0//1; 1//1 1//16 1//4 1//16; 1//1 3//8 1//4 1//32; 1//1 1//4 3//8 1//32; 1//1 1//16 1//16 1//4; 1//1 1//32 3//8 1//4; 1//1 1//4 1//16 1//16; 1//1 1//32 1//4 3//8; 1//1 3//8 1//32 1//4; 1//1 1//4 1//32 3//8]\np.FACETS = pm::Matrix<pm::Rational>\n0 -1 20/7 8/7\n0 -1 20 -1\n0 20/7 -1 8/7\n0 20/7 8/7 -1\n0 20 -1 -1\n1 16/3 16/3 -20/3\n0 8/7 20/7 -1\n0 8/7 -1 20/7\n1 16/3 -20/3 16/3\n0 -1 -1 20\n0 -1 8/7 20/7\n1 -20/3 16/3 16/3\n1 -32/21 -32/21 -32/21\n\n(Polymake.Polytope).dim(p) = 3\np.VERTEX_SIZES = pm::Array<int>\n9 3 4 4 3 4 3 4 4 4\np.VERTICES = pm::Matrix<pm::Rational>\n1 0 0 0\n1 1/16 1/4 1/16\n1 3/8 1/4 1/32\n1 1/4 3/8 1/32\n1 1/16 1/16 1/4\n1 1/32 3/8 1/4\n1 1/4 1/16 1/16\n1 1/32 1/4 3/8\n1 3/8 1/32 1/4\n1 1/4 1/32 3/8\n\n2 : pm::Vector<pm::Rational>\n1 1/16 1/4 1/16\n5 : pm::Vector<pm::Rational>\n1 1/16 1/16 1/4\n7 : pm::Vector<pm::Rational>\n1 1/4 1/16 1/16\nspecial_points = pm::Matrix<pm::Rational>\n1 1/16 1/4 1/16\n1 1/16 1/16 1/4\n1 1/4 1/16 1/16\n\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As can be seen we show consecutive steps of computations: the input matrix, FACETS, then we ask for VERTEX_SIZES, which triggers the convex hull computation. Then we show vertices and print those corresponding to simple vertices. Finally we collect them in special_points.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Observe that a polymake matrix (Polymake.Matrix) implements julia abstract array interface: p.VERTICES[2,:] returns a 1-dimensional slice (i.e. Polymake.Vector), while passing a set of indices (p.VERTICES[special_points, :]) returns a 2-dimensional one.","category":"page"},{"location":"examples/#Notes:","page":"Examples","title":"Notes:","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The same minor (up to permutation of rows) could be obtained by using sets: either julia or polymake ones. However since by default one can not index arrays with sets, we need to collect them first:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"simple_verts = Set(i for (i, vsize) in enumerate(p.VERTEX_SIZES) if vsize == polytope.dim(p)) # Julia set of Int64s\n\nsimple_verts = Polymake.Set(i for (i, vsize) in enumerate(p.VERTEX_SIZES) if vsize == polytope.dim(p)) # polymake set of longs\n\nspecial_points = p.VERTICES[collect(simple_verts), :]","category":"page"},{"location":"examples/#Polymake-syntax-translation","page":"Examples","title":"Polymake syntax translation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following tables explain by example how to quickly translate polymake syntax to Polymake.jl.","category":"page"},{"location":"examples/#Variables","page":"Examples","title":"Variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<table>\n  <tr>\n    <th>\n      Polymake\n    </th>\n    <th>\n      Julia\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <code>$p</code> (reference to 'scalar' variable)\n    </td>\n    <td>\n      <code>p</code> (reference to any variable)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>print $p;</code>\n    </td>\n    <td>\n      <code>print(p)</code> or <code>println(p)</code> or <code>@show p</code>, or just <code>p</code> in REPL\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$i=5; $j=6;</code>\n    </td>\n    <td>\n      <code>i,j = 5,6</code> or <code>i=5; j=6</code><br>\n      (<code>;</code> is needed for separation, can be used to suppress return value in REPL)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$s = $i + $j; print $s;</code>\n    </td>\n    <td>\n      <code>s = i + j</code>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"examples/#Arrays","page":"Examples","title":"Arrays","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<table>\n  <tr>\n    <th>\n      Polymake\n    </th>\n    <th>\n      Julia\n    </th>\n  </tr>\n  <tr>\n    <td>\n      Linear containers with random access\n    </td>\n    <td>\n      Linear containers with random access + all the algebra attached\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>@A = (\"a\", \"b\", \"c\");</code>\n    </td>\n    <td>\n      <code>A = [\"a\", \"b\", \"c\"]</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$first = $A[0];</code>\n      <br>(<code>first</code> is equal to <code>a</code>)\n    </td>\n    <td>\n      <code>first = A[1]</code><br>(note the <code>1</code>-based indexing!)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>@A2 = (3,1,4,2);</code>\n    </td>\n    <td>\n      <code>A2 = [3,1,4,2]</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>print sort(@A2);</code><br>(a copy of <code>A2</code> is sorted)\n    </td>\n    <td>\n      <code>println(sort(A2))</code><br>(to sort in place use <code>sort!(A2))</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$arr = new Array<Int>([3,2,5]);</code><br>(a <code>C++</code> object)\n    </td>\n    <td>\n      <code>arr = [3,2,5]</code><br>(the <code>Int</code> type is inferred)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$arr->[0] = 100;</code><br>(assignment)\n    </td>\n    <td>\n      <code>arr[1] = 100</code><br>(assignment; returns <code>100</code>)\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"examples/#Dictionaries/Hash-Tables","page":"Examples","title":"Dictionaries/Hash Tables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<table>\n  <tr>\n    <th>\n      Polymake\n    </th>\n    <th>\n      Julia\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <code>%h = ();</code>\n    </td>\n    <td>\n      <code>h = Dict()</code><br>it is <b>MUCH</b> better to provide types e.g.<br><code>h = Dict{String, Int}()</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$h{\"zero\"}=0; $h{\"four\"}=4;</code>\n    </td>\n    <td>\n      <code>h[\"zero\"] = 0; h[\"four\"] = 4</code><br>(call returns the value)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>print keys %h;</code>\n    </td>\n    <td>\n      <code>@show keys(h)</code> (NOTE: order is not specified)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>print join(\", \",keys %hash);</code>\n    </td>\n    <td>\n      <code>join(keys(h), \", \")</code><br>(returns <code>String</code>)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>%hash=(\"one\",1,\"two\",2);</code>\n    </td>\n    <td>\n      <code>Dict([(\"one\",1), (\"two\",2)])</code><br>(will infer types)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>%hash=(\"one\"=>1,\"two\"=>2);</code>\n    </td>\n    <td>\n      <code>Dict(\"one\"=>1,\"two\"=>2)</code>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"examples/#Sets","page":"Examples","title":"Sets","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<table>\n  <tr>\n    <th>\n      Polymake\n    </th>\n    <th>\n      Julia\n    </th>\n  </tr>\n  <tr>\n    <td>\n      Balanced binary search trees\n    </td>\n    <td>\n      Hash table with no content\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$set=new Set<Int>(3,2,5,3);</code>\n    </td>\n    <td>\n      <code>set = Set{Int}([3,2,5,3])</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>print $set->size;</code>\n    </td>\n    <td>\n      <code>length(set)</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>@array_from_set=@$set</code>\n    </td>\n    <td>\n      <code>collect(set)</code><br>(NOTE: this creates a <code>Vector</code>, but order is NOT specified)\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"examples/#Matrices","page":"Examples","title":"Matrices","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<table>\n  <tr>\n    <th>\n      Polymake\n    </th>\n    <th>\n      Julia\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <code>new Matrix<T></code><br>Container with algebraic operations\n    </td>\n    <td>\n      <code>Matrix{T} = Array{T, 2}</code><br>**Linear** container with available indexing by <code>2</code>-ples; all algebra attached\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$mat=new Matrix<Rational>([[2,1,4,0,0],[3,1,5,2,1],[1,0,4,0,6]]);</code><br><code>$row1=new Vector<Rational>([2,1,4,0,0]);</code><br><code>$row2=new Vector<Rational>([3,1,5,2,1]);</code><br><code>$row3=new Vector<Rational>([1,0,4,0,6]);</code><br><code>@matrix_rows=($row1,$row2,$row3);</code> (<code>Perl</code> object)<br><code>$matrix_from_array=new Matrix<Rational>(\\@matrix_rows);</code> (<code>C++</code> object)\n    </td>\n    <td>\n      <code>mat = Rational{Int}[2 1 4 0 0; 3 1 5 2 1; 1 0 4 0 6];</code><br><code>row1 = Rational{Int}[2, 1, 4, 0, 0];</code><br><code>row2 = Rational{Int}[3, 1, 5, 2, 1];</code><br><code>row3 = Rational{Int}[1, 0, 4, 0, 6];</code><br><code>matrix_rows = hcat(row1', row2', row3')</code><br>(Julia stores matrices in <b>column major</b> format, so <code>'</code> i.e. transposition is needed)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$mat->row(1)->[1]=7; $mat->elem(1,2)=8;</code>\n    </td>\n    <td>\n      <code>mat[2,2] = 7; mat[2,3] = 8</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$unit_mat=4*unit_matrix<Rational>(3);</code>\n    </td>\n    <td>\n      <code>unit_mat = Diagonal([4//1 for i in 1:3])</code> or <code>UniformScaling(4//1)</code><br>depending on application; both require <code>using LinearAlgebra</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$dense=new Matrix<Rational>($unit_mat);</code><br><code>$m_rat=new Matrix<Rational>(3/5*unit_matrix<Rational>(5));</code><br><code>$m2=$mat/$m_rat;</code><br><code>$m_int=new Matrix<Int>(unit_matrix<Rational>(5));</code><br><code>$m3=$m_rat/$m_int;</code><br>(results in an error due to incompatible types)\n    </td>\n    <td>\n      <code>Array(unit_mat)</code><br><code>m_rat = Diagonal([3//5 for i in 1:5])</code><br><code>m2 = mat/m_rat</code><br><code>m_int = Diagonal([1 for i in 1:5])</code><br><code>m_rat/m_int</code><br>(succeeds due to <code>promote</code> happening in <code>/</code>)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>convert_to<Rational>($m_int)</code><br><code>$z_vec=zero_vector<Int>($m_int->rows)</code><br><code>$extended_matrix=($z_vec\\|$m_int);</code><br>(adds <code>z_vec</code> as the first column, result is dense)\n    </td>\n    <td>\n      <code>convert(Diagonal{Rational{Int}}, m_int)</code><br><code>z_vec = zeros(Int, size(m_int, 1))</code><br><code>extended_matrix = hcat(z_vec, m_int)</code><br>(result is sparse)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$set=new Set<Int>(3,2,5);</code><br><code>$template_Ex=new Array<Set<Int>>((new Set<Int>(5,2,6)),$set)</code>\n    </td>\n    <td>\n      <code>set = Set([3,2,5]);</code><br> <code>template_Ex = [Set([5,2,6]), set]</code>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"examples/#Big-objects-and-properties:","page":"Examples","title":"Big objects & properties:","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<table>\n  <tr>\n    <th>\n      Polymake\n    </th>\n    <th>\n      Julia\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <code>$p=new Polytope<Rational>(POINTS=>cube(4)->VERTICES);</code>\n    </td>\n    <td>\n      <code>p = polytope.Polytope(POINTS=polytope.cube(4).VERTICES)</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$lp=new LinearProgram<Rational>(LINEAR_OBJECTIVE=>[0,1,1,1,1]);</code>\n    </td>\n    <td>\n      <code>lp = polytope.LinearProgram(LINEAR_OBJECTIVE=[0,1,1,1,1])</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$p->LP=$lp;</code><br><code>$p->LP->MAXIMAL_VALUE;</code>\n    </td>\n    <td>\n      <code>p.LP = lp</code><br><code>p.LP.MAXIMAL_VALUE</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$i = ($p->N_FACETS * $p->N_FACETS) * 15;</code>\n    </td>\n    <td>\n      <code>i = (p.N_FACETS * p.N_FACETS) * 15</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>$print p->DIM;</code>\n    </td>\n    <td>\n      <code>polytope.dim(p)</code><br><code>DIM</code> is actually a faux property, which hides a function beneath\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>application \"topaz\";</code><br><code>$p = new Polytope<Max, QuadraticExtension>(POINTS=>[[1,0,0], [1,1,0], [1,1,1]]);</code>\n    </td>\n    <td>\n      <code>p = @pm tropical.Polytope{Max, QuadraticExtension}(POINTS=[1 0 0; 1 1 0; 1 1 1])</code><br>more information on the @pm macro can be found","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"here: @pm","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    </td>\n  </tr>\n</table>","category":"page"},{"location":"shell/#Polymake-REPL","page":"Polymake REPL","title":"Polymake REPL","text":"","category":"section"},{"location":"shell/","page":"Polymake REPL","title":"Polymake REPL","text":"This section shows how to use the embedded polymake shell. For more details on the polymake shell please see the polymake documentation.","category":"page"},{"location":"shell/","page":"Polymake REPL","title":"Polymake REPL","text":"To access it type the dollar $ symbol in an empty line or call Polymake.prompt(). The julia prompt should transition to polymake (common) >, indicating the currently active polymake application.","category":"page"},{"location":"shell/","page":"Polymake REPL","title":"Polymake REPL","text":"There are a few differences to the proper polymake shell:","category":"page"},{"location":"shell/","page":"Polymake REPL","title":"Polymake REPL","text":"For technical reasons the default application is common instead of polytope. Thus most calls from other applications should be prefixed with the corresponding application, e.g. $c = polytope::cube(3). The currently active application can also be changed with application \"someapplication\"; (this will be indicated in the prompt).\nIncomplete input will be executed (and fail) immediately on pressing return. To enter multi-line input please use Alt+Enter.","category":"page"},{"location":"shell/#Passing-data-back-and-forth","page":"Polymake REPL","title":"Passing data back and forth","text":"","category":"section"},{"location":"shell/","page":"Polymake REPL","title":"Polymake REPL","text":"Objects that are known to polymake can be assigned to and retrieved from the special module Polymake.Shell. The variable name in that module corresponds to a polymake shell variable of that name.","category":"page"},{"location":"shell/","page":"Polymake REPL","title":"Polymake REPL","text":"julia> c = polytope.cube(3);\n\njulia> Polymake.Shell.cc = c;\n\npolymake (common) > print $cc->F_VECTOR;\n8 12 6\n\njulia> Polymake.Shell.cc.H_VECTOR\npm::Vector<pm::Integer>\n1 5 5 1","category":"page"},{"location":"shell/","page":"Polymake REPL","title":"Polymake REPL","text":"warning: Warning\nThis feature is considered experimental! There are very little checks on the data being passed around, so please avoid passing temporaries or incompatible objects.","category":"page"},{"location":"#Polymake.jl","page":"Polymake.jl","title":"Polymake.jl","text":"","category":"section"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"Polymake.jl is a Julia package for using polymake, a software for research in polyhedral geometry from Julia. This package is developed as part of the OSCAR project.","category":"page"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"The current version of Polymake.jl relies on polymake version 4.0 or later.","category":"page"},{"location":"#Current-state-of-the-polymake-wrapper","page":"Polymake.jl","title":"Current state of the polymake wrapper","text":"","category":"section"},{"location":"#Data-structures","page":"Polymake.jl","title":"Data structures","text":"","category":"section"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"Big objects, e.g., Polytopes, can be handled in Julia.\nSeveral small objects (data types) from polymake are available in Polymake.jl:\nIntegers (Polymake.Integer <: Integer)\nRationals (Polymake.Rational <: Real)\nVectors (Polymake.Vector <: AbstractVector) of Int64s, Float64s, Polymake.Integers and Polymake.Rationals\nMatrices (Polymake.Matrix <: AbstractMatrix) of Int64s, Float64s, Polymake.Integers and Polymake.Rationals\nSets (Polymake.Set <: AbstractSet) of Int64s\nArrays (Polymake.Array <: AbstractVector, as Polymake.Arrays are one-dimensional) of Int64s and Polymake.Integers\nsome combinations thereof, e.g., Polymake.Arrays of Polymake.Sets of Int32s.","category":"page"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"These data types can be converted to appropriate Julia types, but are also subtypes of the corresponding Julia abstract types (as indicated above), and so should be accepted by all methods that apply to the abstract types.","category":"page"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"Note: If the returned small object has not been wrapped in Polymake.jl yet, you will not be able to access its content or in general use it from Julia, however you can always pass it back as an argument to a polymake function. Moreover you may try to convert to Julia understandable type via macro @convert_to SomeType{Template, Names} obj.","category":"page"},{"location":"#Functions","page":"Polymake.jl","title":"Functions","text":"","category":"section"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"All user functions from polymake are available in the appropriate modules, e.g. homology function from topaz can be called as topaz.homology(...) in julia. We pull the docstrings for functions from polymake as well, so ?topaz.homology (in Julia's REPL) returns the polymake docstring. Note: the syntax presented in the docstring is a polymake syntax, not Polymake.jl one.\nMost of the user functions from polymake are available as appname.funcname(...) in Polymake.jl.  Moreover, any function from polymake C++ library can be called via macro call @pm appname.funcname{C++{template, names}}(...).\nAll big objects of polymake can be constructed either via call to constructor, i.e.","category":"page"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"obj = appname.BigObject(args)","category":"page"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"One can specify some templates here as well: polytope.Polytope{Float64}(...) is a valid call, but the list of supported types is rather limited. Please consider filing a bug if a valid call results in polymake error. For more advanced use see section on @pm macro.","category":"page"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"Properties of big objects are accessible by bigobject.property syntax (as opposed to $bigobject->property in polymake). If there is a missing property please check if it can be accessed by appname.property(object). For example polytope.Polytope does not have DIM property in Polymake.jl sinc DIM is exposed as polytope.dim(...) function.\nMethods are available as functions in the appropriate modules, with the first argument as the object, i.e. $bigobj->methodname(...) can be called via appname.methodname(bigobj, ...)\nA function in Polymake.jl calling polymake may return a big or small object, and the generic return (PropertyValue) is transparently converted to one of the known data types. This conversion can be deactivated by adding keep_PropertyValue=true keyword argument to function/method call.","category":"page"},{"location":"#User-Guide","page":"Polymake.jl","title":"User Guide","text":"","category":"section"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"Getting Started\nUsing Polymake.jl\nExamples","category":"page"},{"location":"#Funding","page":"Polymake.jl","title":"Funding","text":"","category":"section"},{"location":"","page":"Polymake.jl","title":"Polymake.jl","text":"The development of this Julia package is supported by the Deutsche Forschungsgemeinschaft DFG within the Collaborative Research Center TRR 195.","category":"page"}]
}
